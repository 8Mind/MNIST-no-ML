# -*- coding: utf-8 -*-
"""simple_MNIST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vgVjwM4Du_xysDdEdOJDhKOTN1TfCigD
"""

### Timer

import time
start_time = time.time()
print("Notebook execution started...")

### Imports

import torch
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt

### Use GPU if available

device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f'Using {device} device.')

### Define a transformation to convert the images to tensors

transform = transforms.ToTensor()

### Download and load training data

train_dataset = torchvision.datasets.MNIST(root='./data',
                                           train=True,
                                           download=True,
                                           transform=transform)
### Download and load test data

test_dataset = torchvision.datasets.MNIST(root='./data',
                                          train=False,
                                          download=True,
                                          transform=transform)

### Extract images and labels, convert their dtypes, and put them on device

X_train = train_dataset.data.float().to(device)
y_train = train_dataset.targets.to(device)
X_test = test_dataset.data.float().to(device)
y_test = test_dataset.targets.to(device)

### Check shapes

print(f"X_train shape: {X_train.shape}, y_train shape: {y_train.shape}")
print(f"X_test shape: {X_test.shape}, y_test shape: {y_test.shape}")
print("\nSo there are 60,000 train images and 10,000 test images, each of shape (28,28).")

### Plot a few MNIST images

plt.figure(figsize=(10, 10))
for i in range(4):
    plt.subplot(1, 4, i+1)
    plt.imshow(X_train.cpu()[i], cmap='gray')
    plt.title(f'Label: {y_train.cpu()[i]}')

### Write a function which, given some image, returns the index of the training
### image that is "closest" to it (with respect to the Euclidean-distance).

def closest_train_image(img: torch.Tensor()):
  # the expected shape of `img` is (28,28):
  assert img.shape == (28,28)
  # compute the difference between the input image and all train images
  diff = img - X_train # broadcasts over the zeroth index so the shape of `diff`
                       # is (60000,28,28)
  # calculate the Euclidean distances
  dists = torch.linalg.norm(diff, dim=(1, 2)) # computes the Euclidean norm of
                                              # `diff` over the (28,28) shape
  # return the index responsible for the smallest distance
  # (i.e. the index of the closest image)
  return torch.argmin(dists)

### Make predictions for X_test using the label of the closest train image

# for each image in X_test find the index of train image that is most similar to it
idx = [closest_train_image(img) for img in X_test]

# use the label of this "most similar image" as the prediction
y_preds = torch.tensor([y_train[i] for i in idx], device=device)

### Compute the accuracy of prediction

acc = (y_preds==y_test).sum()/len(y_preds)
print(f'The accuracy of prediction is {(acc * 100):.2f}%.')

### How long does it take?

end_time = time.time()
duration = end_time - start_time
print(f"Notebook execution finished in {duration:.2f} seconds.")